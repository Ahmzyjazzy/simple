
/* 
	Copyright (c) 2017-2018 Azeez Adewale <azeezadewale98@gmail.com"> 
	MIT License Copyright (c) 2018 simple 

*/

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\CodeBlockNode.sim" -> simple.parser.node

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\BreakNode.sim"

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\ContinueNode.sim"

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\ClassNode.sim"

package simple.parser

class Parser 

	tokens = []  
	position = 0 
	
	#1
	block endOfStream()
		return position > len(tokens) 
	
	#2
	block parse(intokens)
		tokens = intokens
		position = 0 
		
		nodes = new CodeBlockNode(location(tokens, position))
		while (endOfStream() == false) 
			add(nodes.getChildren(), parseStatement()) 
		end
		return nodes
	
	#3	
	block parseStatement()
		if -> acceptTokenString(TOKENTYPE_IDENTIFIER, "break")
			return new BreakNode(location(tokens, position))
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "continue")
			return new ContinueNode(location(tokens, position))
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "class")
			return parseClass()
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "do")
			return parseDoWhile() 
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "enum")
			println("it enum") 
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "for")
			println("it for") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "call")
			println("it call") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "block")
			println("it block") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "if")
			println("it if") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "private")
			println("it private") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "throw")
			println("it throw") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "return")
			println("it return") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "switch")
			println("it switch") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "trait")
			println("it trait") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "try")
			println("it try") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "until")
			println("it until") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "while")
			println("it while") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "with")
			println("it with") 
		end
		if (position + 1) < len(tokens)
			if matchToken(TOKENTYPE_IDENTIFIER) and tokens[position+1].getTokenType() == TOKENTYPE_COMMA
				return parseMultipleAssignment()
			end
		end
		if (position + 2) < len(tokens) 
			if matchToken(TOKENTYPE_IDENTIFIER) and tokens[position+1].getTokenType() == TOKENTYPE_OPENCURLYBRACE and stringEquals(tokens[position+2].getValue(), "get")
				return parseProperty()
			end
		end
		if matchToken(TOKENTYPE_OPENCURLYBRACE)
			return parseCodeBlockNode()
		else
			println("PARSING : "+tokens[position].getValue())
			return parseExpressionStatement()
		end
		
	#8
	block parseClass()
		clocation = location(tokens, position) inherits = []
		name = expectToken(TOKENTYPE_IDENTIFIER).getValue()
		if -> acceptToken(TOKENTYPE_COLON) or acceptTokenString(TOKENTYPE_IDENTIFIER, "inherit")
			do {
				express = parseExpression()
				add(inherits, express)
			} while -> acceptToken(TOKENTYPE_COMMA) 
			node = parseStatement()
			return new ClassNode(clocation, name, node, inherits)
		end
		node = parseStatement() 
		return new ClassNode(clocation, name, node, null)
	
	#9
	block parseDoWhile()
		dlocation = location(tokens, position)
		expectTokenString(TOKENTYPE_IDENTIFIER, "do")
		body = parseStatement()
		expectTokenString(TOKENTYPE_IDENTIFIER, "while")
		condition = parseStatement()
		return new DoWhileNode(dlocation, condition, body)
		
	#4
	block acceptToken(tokenType)
		ret = matchToken(tokenType)
		if ret == true
			position++
		end
		return ret
	
	#5	
	block acceptTokenString(tokenType, value)
		ret = matchTokenString(tokenType, value)
		if -> ret == true
			position++
		end
		return ret
	
	#6
	block matchToken(tokenType)
		return endOfStream() == false and tokens[position].getTokenType() == tokenType
		
	#7
	block matchTokenString(tokenType, value)
		return endOfStream() == false and tokens[position].getTokenType() == tokenType and stringEquals(tokens[position].getValue(), value)
		
	block expectToken(tokenType)
		if matchToken(tokenType)
			ret = tokens[position] position++
			return ret
		end
		throwScannerException(location(tokens, position), "Expected token of type '"+getTokenTypeValue(tokenType)+"', But got token of type '"+getTokenTypeValue(tokens[position].getTokenType())+"' with value '"+tokens[position].getValue()+"'", UNEXPECTED_TOKEN_TYPE)
		
	block expectTokenString(tokenType, value)
		if matchTokenString(tokenType, value)
			ret = tokens[position] position++
			return ret
		end
		throwScannerException(location(tokens, position), "Expected token of type '"+getTokenTypeValue(tokenType)+"' with value '"+value+"', But got token of type '"+getTokenTypeValue(tokens[position].getTokenType())+"' with value '"+tokens[position].getValue()+"'", UNEXPECTED_TOKEN_TYPE)
	
	block parseExpressionStatement()
		elocation = location(tokens, position)
		expression = parseExpression()
		acceptToken(TOKENTYPE_SEMICOLON)
		if stringEquals(expression.getType(), "block_call_node") or stringEquals(expression.getType(), "binary_operation_node") or stringEquals(expression.getType(), "attribute_access_node") or stringEquals(expression.getType(), "unary_operation_node")
			return new ExpressionStatementNode(elocation, expression)
		end
		return expression
	
	block parseExpression()
		return parseAssignment()
			
	block parseAssignment()
		alocation = location(tokens, position)
		left = parseTenary()
		if matchToken(TOKENTYPE_ASSIGNMENT)
			switch tokens[position+2].getValue()
				case '='
					acceptToken(TOKENTYPE_ASSIGNMENT)
					return new BinaryOperationNode(alocation, BINARYOPERATION_ASSIGNMENT, left, parseAssignment())
			end
		end
		
	block parseTenary()
		tlocation = location(tokens, position)
		left = parseLogicalOr()
		while acceptToken(TOKENTYPE_QUESTION)
			trueStatement = parseExpression()
			expectToken(TOKENTYPE_COLON)
			falseStatement = parseExpression()
			left = new TenaryOperationNode(tlocation, left, trueStatement, falseStatement)
		end
		return left
		
	block parseLogicalOr()
		llocation = location(tokens, position)
		left = parseLogicalAnd()
		while acceptTokenString(TOKENTYPE_OPERATION, "||") or acceptTokenString(TOKENTYPE_IDENTIFIER, "or")
			left = new BinaryOperationNode(llocation, BINARYOPERATION_LOGICALOR, left, parseLogicalOr())
		end
		return left
		
	block parseLogicalAnd()
		alocation = location(tokens, position)
		left = parseEquality()
		while acceptTokenString(TOKENTYPE_OPERATION, "&&") or acceptTokenString(TOKENTYPE_IDENTIFIER, "and")
			left = new BinaryOperationNode(alocation, BINARYOPERATION_LOGICALAND, left, parseLogicalAnd())
		end
		return left
		
	block parseEquality() 
		elocation = location(tokens, position)
		left = parseComparison()
		expr = null
		while matchToken(TOKENTYPE_COMPARISON)
			switch tokens[position].getValue()
				case '=='
					acceptToken(TOKENTYPE_COMPARISON)
					expr = parseComparison()
					if matchToken(TOKENTYPE_COMPARISON)
						return new BinaryOperationNode(elocation, BINARYOPERATION_LOGICALAND, new BinaryOperationNode(elocation, BINARYOPERATION_EQUALTO, left, expr), new BinaryOperationNode(elocation, stringToBinaryOperation(expectToken(TOKENTYPE_COMPARISON).getValue()), expr, parseOr()))
					end
					return new BinaryOperationNode(elocation, BINARYOPERATION_EQUALTO, left, expr)
				case '=='
					acceptToken(TOKENTYPE_COMPARISON)
					expr = parseComparison()
					if matchToken(TOKENTYPE_COMPARISON)
						return new BinaryOperationNode(elocation, BINARYOPERATION_LOGICALAND, new BinaryOperationNode(elocation, BINARYOPERATION_NOTEQUALTO, left, expr), new BinaryOperationNode(elocation, stringToBinaryOperation(expectToken(TOKENTYPE_COMPARISON).getValue()), expr, parseOr()))
					end
					return new BinaryOperationNode(elocation, BINARYOPERATION_NOTEQUALTO, left, expr)
				default break
			end
		end
		return left
		
		block parseComparison()
			plocation = location(tokens, position)
			left = parseOr()
			expr = null
			while matchToken(TOKENTYPE_COMPARISON)
				switch tokens[position].getValue()
					case ">"
						acceptToken(TOKENTYPE_COMPARISON)
						expr = parseOr()
						if matchToken(TOKENTYPE_COMPARISON)
							return new BinaryOperationNode(BINARYOPERATION_LOGICALAND, new BinaryOperationNode(plocation, BINARYOPERATION_GREATERTHAN, left, expr), new BinaryOperationNode(plocation, stringToBinaryOperation(expectToken(TOKENTYPE_COMPARISON).value), expr, parserOr()))		
						end
						return new BinaryOperationNode(plocation, BINARYOPERATION_GREATERTHAN, left expr)
					case ">="
						acceptToken(TOKENTYPE_COMPARISON)
						expr = parseOr()
						if matchToken(TOKENTYPE_COMPARISON)
							return new BinaryOperationNode(BINARYOPERATION_LOGICALAND, new BinaryOperationNode(plocation, BINARYOPERATION_GREATERTHANOREQUAL, left, expr), new BinaryOperationNode(plocation, stringToBinaryOperation(expectToken(TOKENTYPE_COMPARISON).value), expr, parserOr()))		
						end
						return new BinaryOperationNode(plocation, BINARYOPERATION_GREATERTHANOREQUAL, left expr)
					case "<"
						acceptToken(TOKENTYPE_COMPARISON)
						expr = parseOr()
						if matchToken(TOKENTYPE_COMPARISON)
							return new BinaryOperationNode(BINARYOPERATION_LOGICALAND, new BinaryOperationNode(plocation, BINARYOPERATION_LESSERTHAN, left, expr), new BinaryOperationNode(plocation, stringToBinaryOperation(expectToken(TOKENTYPE_COMPARISON).value), expr, parserOr()))		
						end
						return new BinaryOperationNode(plocation, BINARYOPERATION_LESSERTHAN, left expr)
					case ">="
						acceptToken(TOKENTYPE_COMPARISON)
						expr = parseOr()
						if matchToken(TOKENTYPE_COMPARISON)
							return new BinaryOperationNode(BINARYOPERATION_LOGICALAND, new BinaryOperationNode(plocation, BINARYOPERATION_LESSERTHANOREQUAL, left, expr), new BinaryOperationNode(plocation, stringToBinaryOperation(expectToken(TOKENTYPE_COMPARISON).value), expr, parserOr()))		
						end
						return new BinaryOperationNode(plocation, BINARYOPERATION_LESSERTHANOREQUAL, left expr)
				end
			end
			
		
		
		
		
		
		
		
		
		
		
		
		
		
		
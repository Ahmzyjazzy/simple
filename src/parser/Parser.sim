
/* 
	Copyright (c) 2017-2018 Azeez Adewale <azeezadewale98@gmail.com"> 
	MIT License Copyright (c) 2018 simple 

*/

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\BinaryOperation.sim" -> simple.parser

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\CodeBlockNode.sim" -> simple.parser.node

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\BreakNode.sim"

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\ContinueNode.sim"

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\ClassNode.sim"

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\IdentifierNode.sim"

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\BinaryOperationNode.sim"

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\IntegerNode.sim"

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\ExpressionStatementNode.sim"

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\DoWhileNode.sim"

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\EnumNode.sim"

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\StringNode.sim"

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\ForNode.sim"

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\ForEachNode.sim"

call "C:\Users\thecarisma\Documents\SIMPLE GITHUB\simple\src\parser\node\CallNode.sim"

package simple.parser

class Parser 

	tokens = []  
	position = 0 
	
	#1
	block endOfStream()
		return position > len(tokens) 
	
	#2
	block parse(intokens)
		tokens = intokens
		position = 0 
		
		nodes = new CodeBlockNode(location(tokens, position))
		while (endOfStream() == false) 
			add(nodes.getChildren(), parseStatement()) 
		end
		return nodes
	
	#3	
	block parseStatement()
		if -> acceptTokenString(TOKENTYPE_IDENTIFIER, "break")
			return new BreakNode(location(tokens, position))
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "continue")
			return new ContinueNode(location(tokens, position))
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "class")
			return parseClass()
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "do")
			return parseDoWhile() 
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "enum")
			return parseEnum()
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "for")
			return parseFor()
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "call")
			return parseCall()
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "block")
			println("it block") 
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "if")
			println("it if") 
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "private")
			println("it private") 
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "throw")
			println("it throw") 
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "return")
			println("it return") 
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "switch")
			println("it switch") 
		elif -> matchTokenString(TOKENTYPE_IDENTIFIER, "trait")
			println("it trait") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "try")
			println("it try") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "until")
			println("it until") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "while")
			println("it while") 
		elif -> acceptTokenString(TOKENTYPE_IDENTIFIER, "with")
			println("it with") 
		end
		if (position + 1) < len(tokens)
			if matchToken(TOKENTYPE_IDENTIFIER) and tokens[position+1].getTokenType() == TOKENTYPE_COMMA
				return parseMultipleAssignment()
			end
		end
		if (position + 2) < len(tokens) 
			if matchToken(TOKENTYPE_IDENTIFIER) and tokens[position+1].getTokenType() == TOKENTYPE_OPENCURLYBRACE and stringEquals(tokens[position+2].getValue(), "get")
				return parseProperty()
			end
		end
		if matchToken(TOKENTYPE_OPENCURLYBRACE)
			return parseCodeBlockNode()
		else
			return parseExpressionStatement()
		end
		
	#8
	block parseClass()
		clocation = location(tokens, position) inherits = []
		attached = expectTokenString(TOKENTYPE_IDENTIFIER, "class").getAttachedComment()
		name = expectToken(TOKENTYPE_IDENTIFIER).getValue() 
		if -> acceptToken(TOKENTYPE_COLON) or acceptTokenString(TOKENTYPE_IDENTIFIER, "inherit")
			do {
				express = parseExpression()
				add(inherits, express)
			} while -> acceptToken(TOKENTYPE_COMMA) 
			node = parseStatement()
			return new ClassNode(clocation, name, node, inherits)
		end
		node = parseStatement() 
		return new ClassNode(clocation, name, node, null)
		
	block parseCodeBlockNode()
		clocation = location(tokens, position)
		expectToken(TOKENTYPE_OPENCURLYBRACE)
		cblock = new CodeBlockNode(clocation)
		while acceptToken(TOKENTYPE_CLOSECURLYBRACE) == false
			add(cblock.getChildren(), parseStatement())
		end
		return cblock
	
	#9
	block parseDoWhile()
		dlocation = location(tokens, position)
		expectTokenString(TOKENTYPE_IDENTIFIER, "do")
		body = parseStatement()
		expectTokenString(TOKENTYPE_IDENTIFIER, "while")
		condition = parseStatement()
		return new DoWhileNode(dlocation, condition, body)
		
	block parseEnum()
		elocation = location(tokens, position)
		expectTokenString(TOKENTYPE_IDENTIFIER, "enum")
		name = expectToken(TOKENTYPE_IDENTIFIER).getValue()
		enumno = new EnumNode(elocation, name)
		acceptToken(TOKENTYPE_OPENCURLYBRACE)
		count = 0
		while acceptToken(TOKENTYPE_CLOSECURLYBRACE) == false
			num = count++
			attrib = expectToken(TOKENTYPE_IDENTIFIER).getValue()
			if acceptToken(TOKENTYPE_ASSIGNMENT)
				expt = expectToken(TOKENTYPE_INTEGER).getValue()
				num = toNumber(expt)
			end 
			acceptToken(TOKENTYPE_COMMA)  
			enumno.addAttribute(num, attrib)
		end
		return enumno
		
	block parseFor()
		flocation = location(tokens, position)
		expectTokenString(TOKENTYPE_IDENTIFIER, "for")
		acceptToken(TOKENTYPE_OPENPARENTESES)
		if matchToken(TOKENTYPE_IDENTIFIER) and stringEquals(tokens[position+1].getValue(), "in")
			variable = expectToken(TOKENTYPE_IDENTIFIER).getValue()
			expectTokenString(TOKENTYPE_IDENTIFIER, "in")
			expression = parseExpression()
			acceptToken(TOKENTYPE_CLOSEPARENTESES)
			body = parseStatement()
			return new ForEachNode(flocation, variable, expression, body)
		else
			initStatement = parseStatement() 
			acceptToken(TOKENTYPE_SEMICOLON)
			condition = parseExpression()
			acceptToken(TOKENTYPE_SEMICOLON)
			repeatStatement = parseStatement()
			acceptToken(TOKENTYPE_SEMICOLON)
			acceptToken(TOKENTYPE_CLOSEPARENTESES)
			body = parseStatement()
			return new ForNode(flocation, initStatement, condition, repeatStatement, body)
		end
		
	block parseCall()
		clocation = location(tokens, position)
		expectTokenString(TOKENTYPE_IDENTIFIER, "call")
		if matchToken(TOKENTYPE_STRING)
			modulePath = expectToken(TOKENTYPE_STRING).getValue()
			return new CallNode(clocation, modulePath)
		else
			modulePath = ""
			while matchToken(TOKENTYPE_DOT) or matchTokenString(TOKENTYPE_OPERATION, "/")
				modulePath += tokens[position++].getValue()
			end
			do {
				modulePath += expectToken(TOKENTYPE_IDENTIFIER).getValue()
				if matchToken(TOKENTYPE_DOT) or matchTokenString(TOKENTYPE_OPERATION, "/")
					modulePath += "/"
				end
			} while matchToken(TOKENTYPE_DOT) or matchTokenString(TOKENTYPE_OPERATION, "/")
			println("CALL : "+modulePath)
		end
		
		
	#4
	block acceptToken(tokenType)
		ret = matchToken(tokenType)
		if ret == true
			position++
		end
		return ret
	
	#5	
	block acceptTokenString(tokenType, value)
		ret = matchTokenString(tokenType, value)
		if -> ret == true
			position++
		end
		return ret
	
	#6
	block matchToken(tokenType)
		return endOfStream() == false and tokens[position].getTokenType() == tokenType
		
	#7
	block matchTokenString(tokenType, value)
		return endOfStream() == false and tokens[position].getTokenType() == tokenType and stringEquals(tokens[position].getValue(), value)
		
	block expectToken(tokenType)
		if matchToken(tokenType)
			ret = tokens[position] position++
			return ret
		end
		throwScannerException(location(tokens, position), "Expected token of type '"+getTokenTypeValue(tokenType)+"', But got token of type '"+getTokenTypeValue(tokens[position].getTokenType())+"' with value '"+tokens[position].getValue()+"'", UNEXPECTED_TOKEN_TYPE)
		
	block expectTokenString(tokenType, value)
		if matchTokenString(tokenType, value)
			ret = tokens[position] position++
			return ret
		end
		throwScannerException(location(tokens, position), "Expected token of type '"+getTokenTypeValue(tokenType)+"' with value '"+value+"', But got token of type '"+getTokenTypeValue(tokens[position].getTokenType())+"' with value '"+tokens[position].getValue()+"'", UNEXPECTED_TOKEN_TYPE)
	
	block parseExpressionStatement()
		elocation = location(tokens, position) 
		expression = parseExpression() 
		acceptToken(TOKENTYPE_SEMICOLON)
		if stringEquals(expression.getType(), "block_call_node") or stringEquals(expression.getType(), "binary_operation_node") or stringEquals(expression.getType(), "attribute_access_node") or stringEquals(expression.getType(), "unary_operation_node")
			return new ExpressionStatementNode(elocation, expression)
		end
		return expression
	
	block parseExpression()
		return parseAssignment()
			
	block parseAssignment()
		alocation = location(tokens, position)  
		left = parseTenary() 
		if matchToken(TOKENTYPE_ASSIGNMENT) 
			switch tokens[position].getValue()
				case '='
					acceptToken(TOKENTYPE_ASSIGNMENT) ass = parseAssignment()
					return new BinaryOperationNode(alocation, BINARYOPERATION_ASSIGNMENT, left, ass)
				case '+='
					acceptToken(TOKENTYPE_ASSIGNMENT) ass = parseAssignment()
					return new BinaryOperationNode(alocation, BINARYOPERATION_ASSIGNMENT, left, new BinaryOperationNode(alocation, BINARYOPERATION_ADDITION, left, ass))
				case '-='
					acceptToken(TOKENTYPE_ASSIGNMENT) ass = parseAssignment()
					return new BinaryOperationNode(alocation, BINARYOPERATION_ASSIGNMENT, left,  new BinaryOperationNode(alocation, BINARYOPERATION_SUBTRACTION, left, ass))
				case '*='
					acceptToken(TOKENTYPE_ASSIGNMENT) ass = parseAssignment()
					return new BinaryOperationNode(alocation, BINARYOPERATION_ASSIGNMENT, left,  new BinaryOperationNode(alocation, BINARYOPERATION_MULTIPLICATION, left, ass))
				case '/='
					acceptToken(TOKENTYPE_ASSIGNMENT) ass = parseAssignment()
					return new BinaryOperationNode(alocation, BINARYOPERATION_ASSIGNMENT, left,  new BinaryOperationNode(alocation, BINARYOPERATION_DIVISION, left, ass))
				case '%='
					acceptToken(TOKENTYPE_ASSIGNMENT) ass = parseAssignment()
					return new BinaryOperationNode(alocation, BINARYOPERATION_ASSIGNMENT, left,  new BinaryOperationNode(alocation, BINARYOPERATION_MODULUS, left, ass))
				case '<<='
					acceptToken(TOKENTYPE_ASSIGNMENT) ass = parseAssignment()
					return new BinaryOperationNode(alocation, BINARYOPERATION_ASSIGNMENT, left,  new BinaryOperationNode(alocation, BINARYOPERATION_BITSHIFTLEFT, left, ass))
				case '>>='
					acceptToken(TOKENTYPE_ASSIGNMENT) ass = parseAssignment()
					return new BinaryOperationNode(alocation, BINARYOPERATION_ASSIGNMENT, left,  new BinaryOperationNode(alocation, BINARYOPERATION_BITSHIFTRIGHT, left, ass))
				case '&='
					acceptToken(TOKENTYPE_ASSIGNMENT) ass = parseAssignment()
					return new BinaryOperationNode(alocation, BINARYOPERATION_LOGICALAND, left, ass)
				case '|='
					acceptToken(TOKENTYPE_ASSIGNMENT) ass = parseAssignment()
					return new BinaryOperationNode(alocation, BINARYOPERATION_LOGICALAND, left, ass)
				case '^='
					acceptToken(TOKENTYPE_ASSIGNMENT) ass = parseAssignment()
					return new BinaryOperationNode(alocation, BINARYOPERATION_ASSIGNMENT, left,  new BinaryOperationNode(alocation, BINARYOPERATION_BITWISEXOR, left, ass))
				default break
			end
		end
		return left
		
	block parseTenary()
		tlocation = location(tokens, position)
		left = parseLogicalOr()
		while acceptToken(TOKENTYPE_QUESTION)
			trueStatement = parseExpression()
			expectToken(TOKENTYPE_COLON)
			falseStatement = parseExpression()
			left = new TenaryOperationNode(tlocation, left, trueStatement, falseStatement)
		end
		return left
		
	block parseLogicalOr()
		llocation = location(tokens, position)
		left = parseLogicalAnd()
		while acceptTokenString(TOKENTYPE_OPERATION, "||") or acceptTokenString(TOKENTYPE_IDENTIFIER, "or")
			left = new BinaryOperationNode(llocation, BINARYOPERATION_LOGICALOR, left, parseLogicalOr())
		end
		return left
		
	block parseLogicalAnd()
		alocation = location(tokens, position)
		left = parseEquality()
		while acceptTokenString(TOKENTYPE_OPERATION, "&&") or acceptTokenString(TOKENTYPE_IDENTIFIER, "and")
			left = new BinaryOperationNode(alocation, BINARYOPERATION_LOGICALAND, left, parseLogicalAnd())
		end
		return left
		
	block parseEquality() 
		elocation = location(tokens, position)
		left = parseComparison()
		expr = null
		while matchToken(TOKENTYPE_COMPARISON)
			switch tokens[position].getValue()
				case '=='
					acceptToken(TOKENTYPE_COMPARISON)
					expr = parseComparison()
					if matchToken(TOKENTYPE_COMPARISON)
						return new BinaryOperationNode(elocation, BINARYOPERATION_LOGICALAND, new BinaryOperationNode(elocation, BINARYOPERATION_EQUALTO, left, expr), new BinaryOperationNode(elocation, stringToBinaryOperation(expectToken(TOKENTYPE_COMPARISON).getValue()), expr, parseOr()))
					end
					return new BinaryOperationNode(elocation, BINARYOPERATION_EQUALTO, left, expr)
				case '!='
					acceptToken(TOKENTYPE_COMPARISON)
					expr = parseComparison()
					if matchToken(TOKENTYPE_COMPARISON)
						return new BinaryOperationNode(elocation, BINARYOPERATION_LOGICALAND, new BinaryOperationNode(elocation, BINARYOPERATION_NOTEQUALTO, left, expr), new BinaryOperationNode(elocation, stringToBinaryOperation(expectToken(TOKENTYPE_COMPARISON).getValue()), expr, parseOr()))
					end
					return new BinaryOperationNode(elocation, BINARYOPERATION_NOTEQUALTO, left, expr)
				default break
			end
		end
		return left
		
	block parseComparison()
		plocation = location(tokens, position)
		left = parseOr()
		expr = null
		while matchToken(TOKENTYPE_COMPARISON)
			switch tokens[position].getValue()
				case ">"
					acceptToken(TOKENTYPE_COMPARISON)
					expr = parseOr()
					if matchToken(TOKENTYPE_COMPARISON)
						return new BinaryOperationNode(BINARYOPERATION_LOGICALAND, new BinaryOperationNode(plocation, BINARYOPERATION_GREATERTHAN, left, expr), new BinaryOperationNode(plocation, stringToBinaryOperation(expectToken(TOKENTYPE_COMPARISON).value), expr, parserOr()))		
					end
					return new BinaryOperationNode(plocation, BINARYOPERATION_GREATERTHAN, left, expr)
				case ">="
					acceptToken(TOKENTYPE_COMPARISON)
					expr = parseOr()
					if matchToken(TOKENTYPE_COMPARISON)
						return new BinaryOperationNode(BINARYOPERATION_LOGICALAND, new BinaryOperationNode(plocation, BINARYOPERATION_GREATERTHANOREQUAL, left, expr), new BinaryOperationNode(plocation, stringToBinaryOperation(expectToken(TOKENTYPE_COMPARISON).value), expr, parserOr()))		
					end
					return new BinaryOperationNode(plocation, BINARYOPERATION_GREATERTHANOREQUAL, left, expr)
				case "<"
					acceptToken(TOKENTYPE_COMPARISON)
					expr = parseOr()
					if matchToken(TOKENTYPE_COMPARISON)
						return new BinaryOperationNode(BINARYOPERATION_LOGICALAND, new BinaryOperationNode(plocation, BINARYOPERATION_LESSERTHAN, left, expr), new BinaryOperationNode(plocation, stringToBinaryOperation(expectToken(TOKENTYPE_COMPARISON).value), expr, parserOr()))		
					end
					return new BinaryOperationNode(plocation, BINARYOPERATION_LESSERTHAN, left, expr)
				case "<="
					acceptToken(TOKENTYPE_COMPARISON)
					expr = parseOr()
					if matchToken(TOKENTYPE_COMPARISON)
						return new BinaryOperationNode(BINARYOPERATION_LOGICALAND, new BinaryOperationNode(plocation, BINARYOPERATION_LESSERTHANOREQUAL, left, expr), new BinaryOperationNode(plocation, stringToBinaryOperation(expectToken(TOKENTYPE_COMPARISON).value), expr, parserOr()))		
					end
					return new BinaryOperationNode(plocation, BINARYOPERATION_LESSERTHANOREQUAL, left, expr) 
				default break
			end
		end
		return left
		
	block parseOr()
		olocation = location(tokens, position)
		left = parseXor()
		while acceptTokenString(TOKENTYPE_OPERATION, "|")
			left = new BinaryOperationNode(olocation, BINARYOPERATION_BITWISEOR, left, parseOr())
		end
		return left
		
	block parseXor()
		xlocation = location(tokens, position)
		left = parseAnd()
		while acceptTokenString(TOKENTYPE_OPERATION, "^")
			left = new BinaryOperationNode(xlocation, BINARYOPERATION_BITWISEXOR, left, parseXor())
		end
		return left
		
	block parseAnd()
		alocation = location(tokens, position)
		left = parseBitshift()
		while acceptTokenString(TOKENTYPE_OPERATION, "&") pand = parseAnd()
			left = new BinaryOperationNode(alocation, BINARYOPERATION_BITWISEAND, left, pand)
		end
		return left
		
	block parseBitshift()
		blocation = location(tokens, position)
		left = parseAdditive()
		while matchToken(TOKENTYPE_OPERATION)
			switch tokens[position].getValue()
				case "<<"
					acceptToken(TOKENTYPE_OPERATION) pbsl = parseBitshift()
					return new BinaryOperationNode(blocation, BINARYOPERATION_BITSHIFTLEFT, left, pbsl)
				case ">>"
					acceptToken(TOKENTYPE_OPERATION) pbsr = parseBitshift()
					return new BinaryOperationNode(blocation, BINARYOPERATION_BITSHIFTRIGHT, left, pbsr)
				default break
			end
		end
		return left
	
	block parseAdditive()
		alocation = location(tokens, position)
		left = parseMultiplicative()
		while matchToken(TOKENTYPE_OPERATION)
			switch tokens[position].getValue()
				case '+'
					acceptToken(TOKENTYPE_OPERATION) add = parseAdditive()
					return new BinaryOperationNode(alocation, BINARYOPERATION_ADDITION, left, add)
				case '-'
					acceptToken(TOKENTYPE_OPERATION) add = parseAdditive()
					return new BinaryOperationNode(alocation, BINARYOPERATION_SUBTRACTION, left, add)
				default break
			end
		end
		return left 
		
	block parseMultiplicative()
		mlocation = location(tokens, position)
		left = parseUnary()
		while matchToken(TOKENTYPE_OPERATION)
			switch tokens[position].getValue()
				case '*'
					acceptToken(TOKENTYPE_OPERATION) mult = parseMultiplicative()
					return new BinaryOperationNode(mlocation, BINARYOPERATION_MULTIPLICATION, left, mult)
				case '/'
					acceptToken(TOKENTYPE_OPERATION) mult = parseMultiplicative()
					return new BinaryOperationNode(mlocation, BINARYOPERATION_DIVISION, left, mult)
				case '%'
					acceptToken(TOKENTYPE_OPERATION) mult = parseMultiplicative()
					return new BinaryOperationNode(mlocation, BINARYOPERATION_MODULUS, left, mult)
				case '**'
					acceptToken(TOKENTYPE_OPERATION) mult = parseMultiplicative()
					return new BinaryOperationNode(mlocation, BINARYOPERATION_POWER, left, mult)
				case '//'
					acceptToken(TOKENTYPE_OPERATION) mult = parseMultiplicative()
					return new BinaryOperationNode(mlocation, BINARYOPERATION_INTEGERDIVISION, left, mult)
				case '??'
					acceptToken(TOKENTYPE_OPERATION) mult = parseMultiplicative()
					return new BinaryOperationNode(mlocation, BINARYOPERATION_NULLCOALESCING, left, mult)
				case 'is'
					acceptToken(TOKENTYPE_OPERATION) mult = parseMultiplicative()
					return new BinaryOperationNode(mlocation, BINARYOPERATION_IS, left, mult)
				default break
			end
		end
		return left
		
	block parseUnary()
		ulocation = location(tokens, position)
		if matchToken(TOKENTYPE_OPERATION)
			switch tokens[position].getValue()
				case "~"
					acceptToken(TOKENTYPE_OPERATION)
					return new UnaryAccessNode(ulocation, parseUnary(), UNARYOPERATION_BITWISENOT)
				case "!"
					acceptToken(TOKENTYPE_OPERATION)
					return new UnaryAccessNode(ulocation, parseUnary(), UNARYOPERATION_LOGICALNOT)
				case "-"
					acceptToken(TOKENTYPE_OPERATION)
					return new UnaryAccessNode(ulocation, parseUnary(), UNARYOPERATION_NEGATE)
				case "--"
					acceptToken(TOKENTYPE_OPERATION)
					return new UnaryAccessNode(ulocation, parseUnary(), UNARYOPERATION_PREDECREMENT)
				case "++"
					acceptToken(TOKENTYPE_OPERATION)
					return new UnaryAccessNode(ulocation, parseUnary(), UNARYOPERATION_PREINCREMENT)
			end
		end
		return parseAccess()
		
	block parseAccess()
		return parseAccessTerm(parseTerm())
	
	block parseAccessTerm(left)
		alocation = location(tokens, position)
		if matchToken(TOKENTYPE_OPENPARENTESES)
			return parseAccess(new FunctionCallNode(alocation, left, parseArgumentList(), parseInitialAttributes()))
		elif acceptToken(TOKENTYPE_OPENSQUAREBRACE)
			index = parseExpression()
			expectToken(TOKENTYPE_CLOSEQUAREBRACE)
			return parseAccess(new IterableAccessNode(alocation, left, index))
		elif acceptTokenString(TOKENTYPE_OPERATION, "--")
			return new UnaryOperationNode(alocation, left, UNARYOPERATION_POSTINCREMENT)
		elif acceptTokenString(TOKENTYPE_OPERATION, "++")
			return new UnaryOperationNode(alocation, left, UNARYOPERATION_POSTINCREMENT)
		elif acceptToken(TOKENTYPE_DOT)
			return parseAccess(new AttributeAccessNode(alocation, left, expectToken(TOKENTYPE_IDENTIFIER).getValue()))
		end
		return left
		
		block parseTerm()
			tlocation = location(tokens, position)
			if matchToken(TOKENTYPE_CHAR)
				expr = expectToken(TOKENTYPE_CHAR)
				return new CharNode(tlocation, expr.getValue())
			elif matchToken(TOKENTYPE_INTEGER) 
				expr = expectToken(TOKENTYPE_INTEGER)
				return new IntegerNode(tlocation, expr.getValue())
			elif matchToken(TOKENTYPE_FLOAT)
				expr = expectToken(TOKENTYPE_FLOAT)
				return new FloatNode(tlocation, expr.getValue())
			elif matchToken(TOKENTYPE_STRING)
				expr = expectToken(TOKENTYPE_STRING)
				return new StringNode(tlocation, expr.getValue())
			elif matchToken(TOKENTYPE_OPENCURLYBRACE)
				expr = expectToken(TOKENTYPE_INTEGER)
				return new parseDictionaryDeclaration()
			elif acceptToken(acceptToken(TOKENTYPE_OPENPARENTESES))
				expr = parseExpression()
				if (matchToken(TOKENTYPE_COMMA))
					return parseTuple(expr)
				end
				expectToken(TOKENTYPE_CLOSEPARENTESES)
				return expr
			elif matchToken(TOKENTYPE_OPENSQUAREBRACE)
				return parseListDeclaration()
			elif acceptToken(TOKENTYPE_SEMICOLON)
				return new CodeBlockNode(tlocation)
			elif matchTokenString(TOKENTYPE_IDENTIFIER, "=>") or matchTokenString(TOKENTYPE_IDENTIFIER, "lambda")
				return parseLambda()
			elif matchTokenString(TOKENTYPE_IDENTIFIER, "new")
				return parseExpression()
			elif matchTokenString(TOKENTYPE_IDENTIFIER, "thread")
				return parseThread()
			elif position+1 < len(tokens)
				if matchToken(TOKENTYPE_IDENTIFIER) and tokens[position+1].getTokenType() == TOKENTYPE_IDENTIFIER
					return parseEnforcementAssignment()
				elif matchToken(TOKENTYPE_IDENTIFIER)
					rett = expectToken(TOKENTYPE_IDENTIFIER)
					return new IdentifierNode(tlocation, rett.getValue())
				end
			elif matchToken(TOKENTYPE_IDENTIFIER)
				exptk = expectToken(TOKENTYPE_IDENTIFIER)
				return new IdentifierNode(tlocation, exptk.getValue())
			end
			try 
				throwScannerException(location(tokens, position), "Unexpected token of type '"+getTokenTypeValue(tokens[position].getTokenType())+"' with value '"+tokens[position].getValue()+"'", UNEXPECTED_TOKEN_TYPE)
			catch 
				throwScannerException(location(tokens, position), "Unexpected end of source after '"+getTokenTypeValue(tokens[position-1].getTokenType())+"' with value '"+tokens[position-1].getValue()+"'", UNEXPECTED_END_OF_SOURCE)
			end
				
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
			
		
		
		
		
		
		
		
		